

一、快速入门
本地开发
此快速启动方案是基于您首次安装DFINITY及其软件开发包SDK，并将运行互联网计算机作为本地开发环境的一部分。
在一开始，让我们构建并部署一个简单的Hello应用程序，它只有一个叫做greet的功能。如果使用命令行运行应用程序或在浏览器中访问应用程序的警报弹出窗口，greet功能将接受一个文本参数并在一个终端中返回“Hello，everyone！”

准备工作
在下载并安装此版本的DFINITY以及软件开发工具包 SDK之前，请验证以下内容：

已连接互联网，并可以通过macOS 或者 Linux访问本地的 shell 终端。

目前，DFINITY及SDK包只可在macOS 或者 Linux系统中运行。

如果想在项目前端开发中使用 SDK 的模板文件，请安装 node.js。

如果您不确定如何在本地计算机上打开新的终端或如何安装节点node.js,，请参阅新手上路。如果您能够满足上述条件，请继续下载和安装。

下载和安装
你可以直接从本地计算机终端下载最新版本的DFINITY 和软件开发工具包（SDK）。

下载和安装：
打开本地 shell 终端
打开“应用程序”、“实用程序”，然后双击“Terminal ”或按 ⌘+spacebar 打开搜索栏后进入终端。
通过运行以下命令下载并安装 SDK 包：
sh -ci "$(curl -fsSL https://sdk.dfinity.org/install.sh)"
此命令将提示您在安装DFINITY执行命令行(CLI)及本地计算机的依赖项之前，先阅读并接受许可协议。
输入 “y” 并按回车键继续安装。
该命令将显示在本地计算机上正在安装的组件信息。

验证 SDK
如果您在安装运行脚本时没有任何错误，则您启动的在计算机互联网平台上运行的程序都可以在本地计算机上使用。

验证 SDK：
打开本地 shell 终端
检查是否安装了 DFINITY 命令行界面，以及dfx文件是否在路径中可用：
dfx --version
该命令会显示版本信息，如下所示：
dfx 0.6.26
通过运行以下命令， 预览dfx的子命令的信息：
dfx --help
该命令将显示dfx父命令及其子命令的使用信息。

安装 Motoko 语言编辑器插件
如果计划使用 Motoko 语言写程序并以 Visual Studio Code 为编辑器，则可以安装 VSCode 的 Motoko 语言插件，它提供了语法高亮显示、类型信息和自动补全等功能。

安装插件：
下载并安装 Visual Studio Code。
单击“View”，然后选择“Extensions”。
搜索 “motoko”
选择 DFINITY Foundation 发布的 Motoko 语言插件，然后选择“Install”。

如果您的程序有依赖项，您可以安装 Motoko 的软件包管理器，有关说明请参阅 ReadMe。如果您想下载最新的发布，请参阅vessel Github 存储库。

创建新项目

互联网计算机的应用程序将作为项目的开始。您可以使用dfx父命令及其子命令来创建项目。使用dfx创建新项目会将默认的项目目录结构添加到您的开发工作区以启动模板文件。

为您的第一个应用程序创建一个新项目：

打开本地 shell 终端；

通过运行以下命令来创建一个名为hello的新项目：
dfx new hello
dfx new hello命令创建了一个 新的hello项目，其中包含默认项目目录、一些模板文件和项目的 Git 存储库。

如果您使用的是不同的项目名称而不是hello，请记下您使用的名称。您需要在这些说明中使用新的项目而不是hello。

通过运行以下命令更改项目目录：
cd hello

启动本地互联网计算机网络

在构建第一个项目之前，您需要连接到Internet计算机网络并在开发环境中启动本地运行，您需要连接至开发环境中进行本地运行或在可以访问的子网络上远程运行。

这些说明的前提是您正在运行本地Internet网络。如果要连接到外部Internet计算机网络，则可以跳过此部分。作为最佳做法，此步骤需要打开两个终端，以便可以在一个终端中启动并查看网络操作，并在另一个终端中管理项目。

启动本地网络：
在本地计算机上打开新的第二个终端窗口或选项卡。
如果有必要，请导航至项目的根目录。
现在应该保持两个终端呈打开状态，并将项目目录作为两个终端的当前工作目录。
通过运行以下命令，在本地计算机上的第二个终端启动互联网计算机网络：
dfx start
如果系统提示您选择“允许或拒绝传入的网络连接”，请单击“允许”。启动本地网络后，会看到互联网计算机副本启动的消息以及当前网络配置的详细信息。

将显示网络操作的终端窗口打开，并切换到创建新项目的第一个终端窗口。

您可以在终端中执行不显示网络操作的其余步骤。

注册、构建和部署该应用程序

当在开发环境中连接至本地运行的互联网计算机网络后，您可以在本地注册、构建和部署应用程序。

在本地部署第一个应用程序：
如有必要，请检查您是否仍在项目的根目录中。
如有必要，请通过运行以下命令确保节点模块在项目目录中可用：
npm install
有关此步骤的详细信息，请参阅确保项目节点可用。

通过运行以下命令来注册、构建和部署第一个应用程序：

dfx deploy
输出 dfx deploy命令将显示执行操作的信息。例如，此步骤会注册两个网络特定标识符（一个用于hello主程序，一个用于hello_assets前端用户界面）以及类似以下内容的安装信息：
Creating the "default" identity.
  - generating new key at /Users/pubs/.config/dfx/identity/default/identity.pem
Created the "default" identity.
Deploying all canisters.
Creating canisters...
Creating canister "hello"...
Creating the canister using the wallet canister...
Creating a wallet canister on the local network.
The wallet canister on the "local" network for user "default" is "rwlgt-iiaaa-aaaaa-aaaaa-cai"
"hello" canister created with canister id: "rrkah-fqaaa-aaaaa-aaaaq-cai"
Creating canister "hello_assets"...
Creating the canister using the wallet canister...
"hello_assets" canister created with canister id: "ryjl3-tyaaa-aaaaa-aaaba-cai"
Building canisters...
Building frontend...
Installing canisters...
Installing code for canister hello, with canister_id rrkah-fqaaa-aaaaa-aaaaq-cai
Installing code for canister hello_assets, with canister_id ryjl3-tyaaa-aaaaa-aaaba-cai
Authorizing our identity (default) to the asset canister...
Uploading assets to asset canister...
Deployed canisters.

但是，如果您创建了一个不同名称的项目，那么您的容器名称将与您的项目名称相匹配，而不是与hello ，hello_assets匹配。还应注意，第一次部署时，dfx将创建默认身份和由默认身份控制的本地钱包。电子钱包将使您能够将cycles 转移到其他容器。

通过运行以下命令调用hello容器和预定义greet功能：
dfx canister call hello greet everyone
本示例使用dfx canister call将 "everyone" ”作为参数传递给 greet功能。
但请记住，如果创建了不同名称的项目，canister名称将与新的项目名称匹配，您需要修改命令行以匹配您使用的名称而不是hello。

验证命令并显示greet功能的返回值。
例如：
("Hello, everyone!")

测试应用程序的前端信息

既然您已部署应用程序并使用命令行测试了其操作，那么让我们验证是否可以使用网络浏览器访问前端弹出窗口。

打开浏览器

导航到默认地址和端口号127.0.0.1：8000，然后向URL中添加/?canisterId=标识符和hello_assets标识符。

完整的URL应该如下：
http://127.0.0.1:8000/?canisterId=rrkah-fqaaa-aaaaa-aaaaq-cai

导航到此URL时，将显示弹出窗口。例如：
图片: https://uploader.shimo.im/f/XzKX2PPp4ZNd5Ubn.png

键入“greeting”函数，然后单击“OK”以返回该函数。
例如：
图片: https://uploader.shimo.im/f/3X41sncfoytAhivu.png
单击“OK”以关闭警报弹出窗口。


停止本地网络

在浏览器中测试该应用程序后，您可以停止本地互联网计算机网络，使其不在后台运行。

停止本地网络：
在显示网络操作的终端中，按 Control-C 键以中断本地网络进程。
通过运行以下命令，停止在本地计算机上运行的Internet网络：
dfx stop

接下来的步骤
这个快速入门教程只涉及几个关键步骤用来介绍您开发自己的项目时所遵循的基本工作流程。在教学指引 和 Motoko编程语言导引中，有更多详细的示例和教程供您探索。
如有问题请及时联系我们。
想加入这个社区吗？请访问我们的社区论坛。
想继续了解新功能和更新的信息吗？请通过 开发者更新进行注册。

网络部署
二、基本概念
在Internet Computer（互联网计算机，以下称IC）平台上，你可以很快写出一个成功运行的程序，而不用关心其内部工作机理。然而，学一些基本概念，可以帮你更好地发掘其独特的功能。
了解一些IC平台的架构和设计，你可以知道借助平台能为什么目的和哪类应用实现最大的价值。
本章介绍IC架构和操作相关的最关键的组件和术语。
如果你想马上开始写代码，可跳过本章的概念和术语介绍，以后需要的话再来查阅，或查看术语表。
更多入门资料，请查阅以下链接：
 
Overview of the Internet Computer (video)
Building on the Internet Computer: Fundamentals (video)
Introducing Canisters — An Evolution of Smart Contracts (video)
Frequently Asked Questions (video and short articles)
 
2.1 什么是互联网计算机？
互联网计算机（IC）为开发者、组织和企业提供一个计算基础设施，从而构建部署安全、自主且可信的软件程序。在IC的开放平台上，软件和服务是直接在互联网上运行的，而传统的云和分布式架构中，是运行在私有的基础设施或者特定的托管服务里。
作为应用开发者，你可以理解IC提供了以下关键的基础设施： 
一个让通用计算任务在互联网上直接运行的开发通信协议
 一个连接独立计算中心的分布式网络，为计算任务提供计算能力，例如硬件、CPU、内存等
一个运行软件应用的全球接入扩展平台
 
开放架构平台
 
IC运行在某个地方运行的硬件实物，而是由全球的独立数据中心提供的计算资源。IC整合这些资源，为用户和机构提供安全的应用服务和事务处理服务。

你可以认为IC是计算基础设施平台，就像亚马逊Web服务（AWS）、Google云平台（GCP）、微软Azure和企业内部部署的私有云。

和公有云、私有云不同的是，IC平台不属于任何人，也不是由单独一家企业所运营。相反的，IC平台的更新和运营是通过协议定义的分布式治理体系所管理。其架构将多个计算机组合成一个更强大的虚拟机。

组成虚拟机的计算机在全球形成多个数据中心子网。分布式架构确保在没有防火墙和防攻击技术安全的情况下，能够进行安全的通信。独立的数据中心根据其在IC平台贡献的计算资源，获得奖励。
 
构架下一代软件与服务
 
IC协议降低了平台系统的风险，为软件开发、部署和使用提供了创新的机制。

例如，通过IC，开发者只需要关心代码开发，而不用操心运行环境相关的杂事：
物理、虚拟网络配置需求
负载平衡服务
防火墙，网络拓扑和端口管理
数据库配置和维护
存储容量和存储设备

开发人员在IC平台上只要关注如何构建应用创造价值，从而简化了开发流程、加速了软件发布时间、提升了创新速度。

对于用户来说，IC提供了安全的访问环境。因为区块链安全性，运行在IC上的应用不会被黑客攻击，从而保障了用户和组织的软件使用成本。

此外，因为软件服务是自主公开的在IC上运行，开发者能够编写服务互相调用，从而提升了开发效率，为协作创新提供了广阔的空间。

开发者通过密码安全的认证方式访问IC资源，从而避免了对外部认证系统上的用户名和密码登录方式的的依赖。

 
2.2 节点和子网络
2.3 分布式数据中心
2.4 Canister（程序罐）和代码
2.5 Token（令牌？代币？）和运行周期
2.6 Neuron（神经元）和治理模式

三、手把手
安装、升级、删除软件
    如快速入门中所述，您可以通过在终端中运行命令来下载并安装最新版本的 DFINITY Canister SDK 软件包。 本节中的主题提供有关安装，升级和删除 DFINITY Canister SDK 的其他信息。
    从终端直接安装最新版本
从终端命令行下载和安装：
在本机上打开一个终端例如，在 macOS 上，打开“应用程序”文件夹，然后打开“实用程序”，然后双击“终端”。
运行以下命令下载和安装 SDK 包sh -ci "$(curl -fsSL https://sdk.dfinity.org/install.sh) "
    从终端安装指定版本
如果您要安装指定版本，例如测试一个以前的版本，您可以修改命令以包含指定的版本号。
从终端命令行下载和安装指定版本：
在本机上打开一个终端
将需要安装的版本号设置到环境变量 DFX_VERSION，并放置在 curl 命令前例如，安装 0.6.26 版本，运行下列命令：DFX_VERSION=0.6.26 sh -ci "$(curl -fsSL https://sdk.dfinity.org/install.sh) "
    查看许可协议
在本地计算机上安装dfx命令行界面执行文件及其依赖项之前，安装脚本会提示您阅读并接受DFINITY Canister SDK许可协议。 您必须输入y并按回车才能继续安装。
接受许可协议后，安装脚本将显示有关本地计算机上正在安装的组件的信息。
    安装的内容
DFINITY Canister SDK安装脚本会在本地计算机上的默认位置安装多个组件。 下表描述了安装脚本将安装的开发环境组件：

    版本目录中的核心组件
~/.cache/dfinity/versions目录存储DFINITY Canister SDK的一个或多个版本子目录。 每个版本的子目录包含特定版本的DFINITY Canister SDK所需的所有目录和文件。 例如，如果列出~/.cache/dfinity/versions/0.6.26目录的内容，则会看到以下核心组件：
total 349192
drwxr-xr-x  17 pubs  staff       544 Mar 15 11:55 .
drwxr-xr-x   4 pubs  staff       128 Mar 25 14:36 ..
drwxr-xr-x  49 pubs  staff      1568 Mar 15 11:55 base
drwxr-xr-x  20 pubs  staff       640 Mar 15 11:55 bootstrap
-r-x------   1 pubs  staff  66253292 Mar 15 11:55 dfx
-r-x------   1 pubs  staff  10496256 Dec 31  1969 ic-ref
-r-x------   1 pubs  staff   5663644 Dec 31  1969 ic-starter
-r-x------   1 pubs  staff      9604 Dec 31  1969 libcharset.1.0.0.dylib
-r-x------   1 pubs  staff     38220 Dec 31  1969 libffi.7.dylib
-r-x------   1 pubs  staff    668300 Dec 31  1969 libgmp.10.dylib
-r-x------   1 pubs  staff    958248 Dec 31  1969 libiconv.2.4.0.dylib
-r-x------   1 pubs  staff      4200 Dec 31  1969 libiconv.dylib
-r-x------   1 pubs  staff     96900 Dec 31  1969 libz.1.2.11.dylib
-r-x------   1 pubs  staff  15417684 Dec 31  1969 mo-doc
-r-x------   1 pubs  staff  14634020 Dec 31  1969 mo-ide
-r-x------   1 pubs  staff  15111508 Dec 31  1969 moc
-r-x------   1 pubs  staff  49404128 Dec 31  1969 replica
    Motoko主目录
DFINITY Canister SDK的版本子目录中的主目录包含与该版本的DFINITY Canister SDK兼容的Motoko基础库模块。 由于Motoko基础库的发展迅速，因此，您应仅使用与已安装的DFINITY Canister SDK版本打包在一起的基础模块。
    引导目录
引导目录包含已弃用的Web服务器代码。 从版本0.7.0开始，代理可以调用HTTP中间件服务器代替引导程序代码。 这个更改可使Canister可以直接响应HTTP请求，并且可以像传统基于Web的应用程序一样操作。
    升级到最新版本
如果初始安装后有新版本可下载，您应当尽早安装新版本以得到最新的修补和增强。您可以使用dfx upgrade命令将当前安装的版本与可下载的最新版本进行比较。如果有较新版本的dfx，则dfx upgrade命令将自动下载并安装最新版本。
在安装新版本之前，您无需卸载软件。但是，如果要执行全新安装而不是升级，则可以按照卸载软件中的说明先卸载软件，然后重新运行download and installation命令。
有关最新版本中的特点和修补的信息，请参阅发行说明。
    卸载软件
当您安装DFINITY Canister SDK时，安装脚本会将所需的二进制文件放在本地目录中并创建缓存。 您可以通过运行.cache文件夹中的卸载脚本从本地计算机中删除SDK二进制文件和缓存。
例如：
~/.cache/dfinity/uninstall.sh
如果您是想卸载软件后立即重新安装一个干净版本，运行以下命令：
~/.cache/dfinity/uninstall.sh && sh -ci "$(curl -sSL https://sdk.dfinity.org/install.sh)"
设计Apps
在您提出应用程序构想时，您将做出许多有关如何构建和组织项目的设计决定。这些设计决定中的大多数与您将应用程序部署在传统云服务还是Internet Computer上无关。但是，如果要在Internet Computer上进行部署，则在规划应用程序的实现时，应特别注意一些设计决策。
    单或多个Canister架构
在设计应用程序时，您首先要考虑的是将其封装在单个容器中还是由多个容器组成。
例如，如果要编写没有前端的简单服务，您可能想要使用单个容器来简化项目管理和维护，并着重于添加功能。如果您的应用程序同时具有前端资源和后端业务逻辑，则您的项目可能至少包含两个容器，一个容器用于管理用户界面组件，另一个容器用于应用程序提供的后端服务。
在规划中，您可能还考虑将一些常见的可重用服务放在其自己的容器中，以便可以从其他更专业的容器中导入和调用它们，或将其提供给其他开发人员使用。LinkedUp示例应用程序通过将专业服务应用分为两个容器来说明此方法。在LinkedUp示例中，建立社交连接的功能在连接Canister中定义，并且与用于设置在linkedup Canister中定义的专业配置的功能分开。很容易想象用第三个Canister来扩展应用，例如基于配置属性和共享连接来安排事件。
    将Actor从类型和实用程序区分开
    使用查询调用
    数据存储与检索
对于许多应用程序，数据库主要用于提供记录的长期存储，可以使用一个或多个关键字段有效地检索记录。在Internet Computer上，通常通过诸如哈希表之类的数据结构来解决这种用例。代替传统的数据库，Internet Computer使您可以使用稳定的内存来处理长期数据存储（通常称为正交持久性），并可以使用查询调用来检索数据。 尽管这种方法适用于大多数应用程序和简单的键值数据库请求，但它不能完全模拟关系数据库。
管理项目
您可以通过修改每个项目的dfx.json配置文件来修改项目的一些关键设置。 您可以使用dfx config命令以程序化方式更改这些设置，也可以直接手动编辑dfx.json文件。
如何更改源文件目录
在使用dfx build命令编译项目的源代码之前，您可能需要检查用于存储程序源代码的默认位置。默认情况下，用于创建新项目的名称是用于一个数据Canister（canister_name）和一个资源容器（canister_name_assets）的名称，并且程序源代码应位于src / canister_name目录中。
但是，根据应用程序的复杂度和体系结构，您可能需要修改源代码的默认位置。
例如，对于一个简单的程序，您可能想要去掉一个目录层级，并将源代码放在src目录中：
 "main": "src/main.mo"
对于更复杂的应用程序，您可能需要使用多层目录结构：
"canisters": {
  "profiles": {
    "main": "src/profiles/utils/main.mo"
  },
  "events": {
    "main": "src/events/calendar/main.mo"
  },
  "media": {
    "main": "src/events/reports/main.mo"
  }
}
提示：如果您修改源代码目录的默认设置，请确保dfx.json配置文件中的设置与文件系统上的目录位置匹配。
如何修改主程序文件名
在使用dfx build命令编译项目的源代码之前，应验证用于程序源代码的位置和文件名。
例如，如果要为阶乘程序构建容器，并且该程序的源代码位于src/math/factorial.mo中，您应确保在配置文件的Canister部分指定了正确的路径。
例如：
   "canisters": {
    "myFactorial": {
      "main": "src/math/factorial.mo",
请记住，更改程序文件名的配置设置仅会影响dfx build命令在哪里寻找要编译的源代码。在配置文件中进行更改不会重命名文件系统上的任何文件或目录。如果更改主程序文件的路径或文件名，请确保更改项目目录中的名称和位置。
如何更改应用前端服务的位置
您可以通过修改dfx.json配置文件中的设置来更改默认的主机名和端口号，以运行本地Internet Computer副本进程并为应用程序前端提供服务。
例如：
 "start": {
      "port": 8000,
      "address": "127.0.0.1",
      "serve_root": "src/hello/public/"
使用不同语言开发
本文档中的大多数示例都使用Motoko（一种专门设计用于Internet Computer的编程语言）。但是，潜在地，您可以使用可编译为WebAssembly的任何语言编写程序，以部署在Internet Computer上运行的应用程序。
使用Rust
您可以使用Cargo编译程序并使用WebAssembly作为输出来创建一个Rust项目运行在Internet Computer上。
本节总结了在Internet Computer上将Rust程序作为Canister部署时所涉及的关键步骤。然而，您应该知道，此处描述的步骤仅说明了一种方法，其他的实现方式也是可能的。
请注意，Rust Canister开发工具包（Rust CDK）提供了一些快捷方式，可简化编写查询和更新函数调用的过程，并提供了一些示例来帮助您开始构建基于Rust的项目，但您也可以为Internet Computer开发应用程序而不使用Rust CDK。
创建项目
因为大部分的Rust程序员使用Cargo来处理创建和包管理任务（储如下载和编译依赖库），首先使用Cargo命令行接口来创建一个新的Rust项目。
或者，您可以使用DFINITY Canister软件开发包(SDK)来代替Cargo创建新的项目，但是使用Cargo来创建新项目代表了Rust项目的典型工作流程。
创建一个新项目：
在本地计算机上打开终端
运行以下命令以验证Cargo是否安装:
cargo --version
更改到您的Internet Computer或Rust示例项目的目录。
运行类似以下命令来创建新项目：
cargo new my_rust_program
该命令创建一个新的my_rust_program目录，包含了默认的Cargo.toml文件和带有默认main.rs文件的src目录。
运行下列命令进入到项目目录：
cd my_rust_program
如果您显示该目录内容，您将看到目录下仅包含Cargo.toml文件和src目录。为了编译项目以使能在Internet Computer上运行，您还需要一些其他文件。
修改Cargo配置文件
Cargo.toml文件为每个Rust包提供一个清单。清单包含了包的配置明细。为准备Rust项目运行在Internet Computer上，我们需要拷贝默认的Cargo.toml文件并修改一些详细配置信息。
修改Cargo.toml文件：
如果有必要，运行pwd命令来检查您是否在项目的根目录下。
运行以下命令拷贝默认的Cargo.toml文件到src目录：
cp Cargo.toml src/Cargo.toml
在Internet Computer上运行的项目通常使用一个项目级别的Cargo.toml文件为项目的Canister成员设置工作区，并在源代码目录中使用第二个Cargo.toml文件为每个Canister配置参数。
用文本编辑器打开项目根目录下的Cargo.toml文件
默认情况下，该文件包含[package]和[dependencies]部分。
用类似以下[workspace]部分来替换[package]：
[workspace]
members = [
    "src/my_rust_program",
]
For information about the [workspace] section and [workspace] keys, see Workspaces. For information about the other sections and keys you can configure in the Cargo.toml file, see The Manifest Format.
有关[workspace]部分和键值信息，请参阅工作区。有关Cargo.toml配置的其他部分和键值，请参阅清单格式。
删除[dependencies]部分
保存并关闭文件
在文本编辑器中打开src/Cargo.toml文件
增加类似以下带有主要源代码目录的[lib]
[lib]
path = "main.rs"
更新[dependencies]部分的依赖项
保存并关闭文件
添加Canister配置文件
当您用DFINITY Canister SDK创建一个新项目时，dfx new命令自动添加一个默认dfx.json配置文件到项目目录。因为他们已经使用Cargo来创建Rust项目，所以您需要手工在项目目录下创建该文件。
添加dfx.json配置文件：
如有必要，用pwd命令来检查您是否仍在项目目录下。
在项目根目录下创建一个dfx.json配置文件。
在文本编辑器中打开dfx.json文件。
添加类似以下设置的version和canisters键到dfx.json文件
{
  "version": 1,
  "canisters": {
    "my_rust_program": {
      "type": "custom",
      "candid": "src/my_rust_program.did",
      "wasm": "target/wasm32-unknown-unknown/debug/my_rust_program.wasm",
      "build": "cargo build --target wasm32-unknown-unknown --package my_rust_program"
    }
  }
}
让我们详细看看这些配置
version用于标识创建项目软件的版本号
canisters部分指定项目的Canister名字。在本例中，仅有一个名为my_rust_program的Canister
因为不是可标识的canister类型之一（motoko或assets），type键设置为custom
candid键指定用于此项目的Candid接口描述文件的名称和位置。
wasm键指定cargo编译命令生成的WebAssembly文件路径
build键指定用于编译输出的cargo命令
These are the minimum settings required. As you build more complex programs, you might need to include additional configuration details in the Cargo.toml file, the dfx.json file, or both files. 这些是最小配置需要。随着您构建更复杂的程序，您会需要在Cargo.toml, dfx.json中进行其他详细配置
保存并关闭文件
创建一个Candid接口描述文件
除了dfx.json配置文件之外，您还需要一个Candid接口描述文件（例如，my_rust_program.did），以映射程序输入参数和返回值格式到Candid中伪代码表现形式。
添加Candid接口描述文件：
如有必要，用pwd命令来检查您是否仍在项目目录下。
在项目的src目录下创建一个新的Candid接口描述文件（例如my_rust_program.did）
在文本编辑器中打开这个描述文件并且为程序中每一个函数添加描述
例如，如果my_rust_program是一个简单的计数器程序，使用increment, read和write函数，my_rust_program.did看起来象这样：
service : {
  "increment": () -> ();
  "read": () -> (nat) query;
  "write": (nat) -> ();
}
修改默认程序
当您创建一个新的项目，src目录包含了一个"Hello World!"的模板main.rs文件
修改模板源代码：
在文本编辑器中打开src/main.rs文件并删除存在的内容
编写您想在Internet Computer上发布的程序
编写程序时，请注意有两种类型的调用（更新调用和查询调用），更新函数使用异步消息
保存并关闭src/main.rs文件
连接到网络并部署
在您部署和测试程序之前，您有以下工作要做：
连接您开发环境Internet Computer网络本地运行或连接到您能访问的子网上远程运行
为您的应用注册一个网络特定标识符
编译带有WebAssembly输出目标的程序
因为您使用编译成WebAssembly的cargo build命令配置了自定义dfx.json文件，所以可以使用dfx命令行接口和标准工作流程来执行所有其余步骤。
本地生成和部署：
如有必要，用pwd命令来检查您是否仍在项目目录下
打开一个新的终端窗口或tab页并进入项目目录
例如，在macOS终端上执行以下任一操作：
单击Shell，在当前工作目录选择新选项卡以打开新的终端
Click Shell and select New Window, then run cd ~/ic-projects/location_hello in the new terminal if your location_hello project is in the ic-projects working folder. 点击Shell，选择新窗口，在新终端运行cd ~/ic-projects/location_hello（如果location_hello项目在ic-projects工作目录）
您现在应该打开了两个已进入当前工作目录的终端
运行以下命令在本地计算机上启动Internet Computer网络
dfx start
根据您的平台和本地安全设置，您可能会看到一个警告。如果提示您允许或拒绝传入网络连接，请单点允许
离开网络操作显示信息的终端并切换到原来的终端
运行以下命令为应用注册一个唯一Canister标识符：
dfx canister create --all
运行以下命令生成程序：
dfx build
运行以下命令在本地部署程序：
dfx canister install --all
从命令行或浏览器测试功能
使用C
因为Internet Computer支持应用编译到标准的WebAssembly模块，您能用象C, C++, Objective-C和Objective-C++语言标准编译器和工具和Clang编译器来生成应用程序。
为了说明如何迁移用C编写的程序以在Internet Computer上运行，让我们看一下示例库中的简单reverse.c程序。reverse.c程序包含一个名为go的函数，该函数可以反转字符串。
搭建开发环境
要将reverse.c程序编译为WebAssembly，需要安装clang编译器和标准库。 您可以通过运行以下命令来检查本地计算机上是否已安装clang：
clang --version
如果安装了clang，该命令将显示类似于以下内容的信息：
clang version 10.0.0
Target: x86_64-apple-darwin19.5.0
Thread model: posix
InstalledDir: /usr/local/opt/llvm/bin
如果该命令未返回版本信息，请在继续之前安装clang。 根据您所使用的操作系统，安装clang的步骤会有所不同。 例如，在Debian Linux上，运行以下命令：
sudo apt-get install clang lld gcc-multilib
在macOS上，您可以通过安装开发人员命令行工具或使用Homebrew安装LLVM来安装clang。 例如，如果未安装clang，请运行以下命令：
brew install llvm
将程序编译为WebAssembly
您可以先使用clang进行编译，然后使用wasm-ld进行链接，以将C程序编译为作为WebAssembly模块运行。 根据所使用的操作系统和Clang版本，您可能会使用其他版本的WebAssembly链接器，例如macOS上的wasm-ld或Debian上的wasm-ld-8。
在macOS上编译为WebAssembly：
通过运行以下clang命令来编译程序：
clang --target=wasm32 -c -O3 reverse.c
通过运行以下wasm-ld命令，运行链接器以创建WebAssembly模块：
wasm-ld --no-entry --export-dynamic --allow-undefined reverse.o -o reverse.wasm
创建一个最小的配置文件
接下来，您需要准备一个简单的配置文件，标识了能安装在Internet Computer上的reverse二进制包和一个build目录，以便您能使用dfx命令行接口来作为Canister安装并运行。
准备配置文件和构建目录：
使用以下命令来创建一个带有canisters键的dfx.json文件
echo '{"canisters":{"reverse":{"main":"reverse"}}}' > dfx.json
copy
使用以下命令创建一个build目录
mkdir build
运行以下命令创建一个reverse目录
mkdir build/reverse
运行以下命令拷贝WebAssembly模块到新的build/reverse目录
cp reverse.wasm build/reverse/
创建一个最小接口描述文件
在标准开发工作流程中，运行dfx build命令会在Canister的输出目录中创建多个文件，包括一个或多个Candid接口描述（.did）文件，这些文件处理与程序功能关联的数据类型的类型匹配。
有关用于不同数据类型的语法的详细信息，请参见Candid规范。
为此程序创建一个Candid接口描述文件：
在您为reverse.c程序源创建的build目录中打开一个终端
创建一个名为reverse.did的新文本文件。
添加go函数的描述。
例如：
service : {
  "go": (text) -> (text);
}
保存并关闭文件
部署和测试程序
在部署和测试程序之前，您需要执行以下操作：
连接到Internet Computer网络，该网络可以在您的开发环境中本地运行，也可以在您可以访问的子网中远程运行。
为应用注册一个特定网络标识
在本地部署和测试：
在本地计算机上打开一个新的终端窗口或选项卡。
例如，如果在macOS上运行Terminal，请单击Shell，然后选择New Tab在当前工作目录中打开一个新终端。
通过运行以下命令，在第二个终端中的本地计算机上启动Internet Computer网络：
dfx start
通过运行以下命令，为reverse应用程序注册唯一的容器标识符
dfx canister create --all
通过运行以下命令在本地网络上部署默认程序：
dfx canister install --all
通过运行以下命令在程序中调用go函数：
dfx canister call reverse go reward
("drawer")
您可以在示例库中找到C程序的其他示例。
添加前端资源
教程介绍了一些为项目构建前端用户界面的基本方法。 例如，这些教程演示了：
使用Candid作为基本界面来公开和测试Canister中的功能。
使用原始JavaScript显示简单的弹出警报窗口。
使用React和已编译的JavaScript将HTML属性和元素直接嵌入页面中。
使用React和TypeScript从外部文件导入CSS属性。
本节将仔细研究默认的前端模板，前端配置选项，以及使用其他框架为您的项目构建用户界面。
如何使用默认模板
就像您在教程中可能已经注意到的那样，项目默认包含一个模板webpack.config.js文件。 因为webpack是基于JavaScript的应用程序的流行且高度可配置的模块捆绑器，所以默认的webpack.config.js文件使添加要使用的特定模块（如react和markdown）变得容易。
默认情况下，模板webpack.config.js文件还会根据项目dfx.json文件中的条目创建Canister别名。 如果查看模板webpack.config.js文件中的代码，您会发现它使用以下代码块执行此别名创建任务：
// List of all aliases for canisters. This creates the module alias for
// the `import ... from "ic:canisters/xyz"` where xyz is the name of a
// canister.
const aliases = Object.entries(dfxJson.canisters)
    .filter(([name,value]) => value.main)
    .reduce((acc, [name,value]) => {
  const outputRoot = path.join(__dirname, dfxJson.defaults.build.output, name);
  const filename = path.basename(value.main, ".mo");
  return {
    ...acc,
    ["ic:canisters/" + name]: path.join(outputRoot, filename + ".js"),
    ["ic:idl/" + name]: path.join(outputRoot, filename + ".did.js"),
  };
}, {});
入口和输出配置
创建容器别名后，模板webpack.config.js文件将生成一个Webpack配置，该配置将Canister别名作为导入的模块自动添加到项目dfx.json文件中定义的默认前端入口点中。例如，使用默认设置，将类似于以下内容的导入添加到src/CANISTER_assets/public/index.js文件中：
import CANISTER-ALIAS from 'ic:canisters/CANISTER-ALIAS';
确保nodejs在项目中可用
由于项目依赖于webpack为默认的前端提供框架，因此您必须在开发环境中安装node.js并在项目目录中对其进行访问。
如果要在不使用默认Webpack配置和Canister别名的情况下开发项目，则可以从dfx.json文件中删除资源Canister，也可以使用特定的Canister名称来构建项目。
dfx build hello
如果您使用默认的Webpack配置并且运行dfx build失败，则应尝试在项目目录中运行npm install，然后重新运行dfx build。
如果在项目目录中运行npm install不能解决问题，则应检查webpack.config.js文件的配置是否存在语法错误。
在React框架中使用其他模块
示例库中的一些教程和示例项目说明了如何使用npm install命令添加React模块。 您可以使用这些模块来构造要在项目中使用的用户界面组件。 例如，您可以运行以下命令来安装react-router模块：
npm install --save react react-router-dom
然后，您可以使用该模块构造类似于以下内容的导航组件：
import React from 'react';
import { NavLink } from 'react-router-dom';

const Navigation = () => {
  return (
    <nav className="main-nav">
      <ul>
        <li><NavLink to="/myphotos">Remember</NavLink></li>
        <li><NavLink to="/myvids">Watch</NavLink></li>
        <li><NavLink to="/audio">Listen</NavLink></li>
        <li><NavLink to="/articles">Read</NavLink></li>
        <li><NavLink to="/contribute">Write</NavLink></li>
      </ul>
    </nav>
  );
}

export default Navigation;
管理Canisters
如果您通过遵循“教程”部分中的教程或从示例存储库中克隆示例来尝试使用DFINITY容器软件开发套件（SDK），则您已经熟悉如何将程序构建和部署为容器。 本节提供有关容器生命周期以及如何管理容器的其他信息。
注册Canister标识符
根据您喜欢的开发工作流程，可以在准备编译程序之前或之后注册一个唯一的Canister标识符。 例如，如果要在编写任何代码之前为子网上的程序保留唯一的标识符，可以通过运行dfx canister create命令来实现。 此命令实际上创建了一个空的Canister占位符，您以后可以在其中安装代码。
为Canister注册唯一标识符：
在本地计算机打开终端
通过运行与以下命令类似的命令，为计划创建的Canister创建一个新项目：
dfx new YOUR-PROJECT-NAME
请注意，默认情况下，您用于项目的名称也用作Canister名称。
进入新项目目录
打开dfx.json配置文件，并设置要使用的Internet Computer网络的主机和端口。
如果您将本地主机用作Internet Computer网络提供者，则可以跳过此步骤。
如果您想在编译代码前为其他Canister创建标识符，在配置文件中可以随意修改Canister名字或添加Canister设置
运行以下命令启动Internet Compter网络
dfx start --background
在大多数情况下，仅当您在本地运行Internet Computer网络时，才需要执行此步骤。
如果要注册要在远程网络上运行的Canister，则应包括--network命令行选项，以在该网络上执行任务。
通过运行以下命令，为dfx.json中定义的Canister注册唯一标识符：
dfx canister create --all
该命令创建.dfx/local目录，并将canister_ids.json文件添加到该目录。
用本地标识符构建一个Canister
为项目编写源代码后，需要将其编译为WebAssembly模块，然后才能将其作为Canister部署到网络中。
如果仅编译项目以进行本地调试，则可以为项目生成本地定义的标识符。
生成本地定义的标识符：
创建一个满足需求的具有配置设置和程序逻辑的项目
如有必要，启动Internet Computer网络
多数情况下，仅当您在本机运行Internet Computer网络，才需要执行该步骤
如果要编译Canister以在远程网络上运行，则应包括--network命令行选项，以在该网络上执行任务。
通过运行以下命令，为dfx.json中定义的Canister生成硬编码的本地标识符：
dfx build --check
请注意，必须先注册唯一的Canister标识符来替换本地定义的标识符，然后才能在Internet Computer网络上部署项目。
在Internet Computer网络上部署Canister
编译程序后，可以将编译后的代码安装在本地运行的Internet Computer网络上，也可以安装在远程网络上。
预先创建的Canister标识符或在构建过程中创建的Canister标识符决定了在部署过程中代码的安装位置。
首次在Internet Computer网络上进行部署：
打开一个终端并进入项目目录
如有必要，启动Internet Computer网络
多数情况下，仅当您在本机运行Internet Computer网络，才需要执行该步骤
如果Canister安装在远程网络上，则应包括--network命令行选项，以在该网络上执行任务。
验证您具有要部署的所有Canister的标识符。
运行以下命令部署所有Canister
dfx canister install --all
查找Canister标识符 
所有Canister都具有唯一的，特定网络的标识符。 您通常需要使用这些标识符与Canister进行交互。 例如，如果要访问应用程序的前端Canister或使用Candid Web接口与服务进行交互，则必须指定适当的Canister标识符。
由于标识符是特定于网络的，因此用于存储信息的文件位于不同的目录中。 例如，本地部署的Canister的标识符位于项目的.dfx/local/canister_ids.json文件中。
您可以通过运行dfx canister id命令来查找任何特定Canister的标识符。 例如，要查找部署在本地网络上的名为lookup的Canister标识符，可以运行以下命令：
dfx canister id lookup
要查找由IC别名指定的网络上部署的同一Canister的标识符，请运行以下命令：
dfx canister --network=ic id lookup
为现有的Canister添加钱包
当您本地开发创建新项目时会同时自动创建一个默认钱包，如果想为原来创建的Canister添加一个钱包，您可强制用dfx通过手动步骤来生成。
为现有Canister添加钱包：
打开一个终端并进入项目目录
如有必要，运行以下命令来停止Internet Computer网络
dfx stop
删除.dfx目录
使用以下命令启动Internet Computer网络
dfx start --clean
重新安装Canister
在开发周期中，您可能会安装，然后随着调试和改进的需要替换程序。
在这种情况下，您可能希望保留已注册的Canister标识符，但不保留任何Canister的代码或状态。例如，您的Canister可能只包含您不想保留的测试数据，或者您可能决定完全更改程序，但想在先前安装的Canister标识符下重新安装。
在Internet Computer网络上重新安装：
打开一个终端并进入项目目录
如有必要，启动Internet Computer网络
多数情况下，仅当您在本机运行Internet Computer网络，才需要执行该步骤
如果Canister重新安装在远程网络上，则应包括--network命令行选项，以在该网络上执行任务。
验证您具有要重新部署的所有Canister的标识符。
运行以下命令以重新部署所有Canister
dfx canister install --all --mode reinstall
请注意，无论Canister是否具有与之关联的代码或状态，都可以使用重新安装模式来替换
为拥有一个Canister设置身份
在大多数情况下，第一次运行dfx canister create命令时会自动为您创建一个默认用户身份。此默认身份包括为您的本地用户帐户生成的公钥和私钥对。通常，此默认标识还是您创建的所有项目和您部署的所有Canister的默认所有者。但是您可以创建和使用您选择的用户来代换默认用户。
例如，以下场景说明了创建一个registered_owner身份，该身份随后用于注册，构建，部署和调用pubs项目。
为项目设置身份：
运行以下命令创建新项目：
dfx new pubs
运行以下命令进入项目目录：
cd pubs
运行以下命令在后台启用Internet Computer网络：
dfx start --background
运行以下命令创建一个新的身份
dfx identity new registered_owner
运行以下命令，将当前用户设置为registered_owner
dfx identity use registered_owner
运行以下命令为项目注册，构建和部署Canister：
dfx canister create --all
dfx build --all
dfx canister install --all
这些命令使用registered_owner身份运行，从而使该用户成为已部署Canister的所有者。
运行以下命令，通过调用greet函数以验证部署是否成功：
dfx canister call pubs greet '("Sam")'
管理Canister运行状态
在Internet Computer上部署Canister之后，它可以开始接收和处理来自用户和其他Canister的请求。 可用于发送请求和接收回复的Canister被视为处于运行状态。
尽管默认情况下通常通常将Canister置于运行状态，但在某些情况下，您可能希望暂时或永久停止它。 例如，您可能要在升级之前停止。 停止Canister有助于对正在处理的，需要运行至完成或回滚的所有消息进行合适的处理。 您可能还想停止Canister以干净地清除其消息队列，这是删除Canister的先决条件。
您可以通过运行dfx canister status命令来检查所有或指定Canister的当前状态。 例如，要查看在本地Internet Computer网络上运行的所有Canister的状态，可以运行以下命令：
dfx canister status --all
如果Canister当前正在运行，返回的输出类似于以下内容：
Canister status_check's status is Running.
Canister status_check_assets's status is Running.
您可以通过运行dfx canister stop命令来停止当前正在运行的Canister。
dfx canister stop --all
返回的输出类似于以下内容：
Stopping code for canister status_check, with canister_id 75hes-oqbaa-aaaaa-aaaaa-aaaaa-aaaaa-aaaaa-q
Stopping code for canister status_check_assets, with canister_id cxeji-wacaa-aaaaa-aaaaa-aaaaa-aaaaa-aaaaa-q
如果要重新运行dfx canister status命令，则可能会看到“已停止”状态，表明没有待处理的消息，或者“正在停止”状态，表明有正在处理的消息需要处理。
要重新启动Canister（例如，在成功升级之后），您可以运行dfx canister start命令。 例如，要重新启动在本地Internet Computer网络上运行的所有Canister，运行以下命令：
dfx canister start --all
返回的输出类似于以下内容：
Starting code for canister status_check, with canister_id 75hes-oqbaa-aaaaa-aaaaa-aaaaa-aaaaa-aaaaa-q
Starting code for canister status_check_assets, with canister_id cxeji-wacaa-aaaaa-aaaaa-aaaaa-aaaaa-aaaaa-q
升级Canister
与保留Canister标识符但不保留状态的替换不同，Canister升级使您能够保留已部署Canister的状态并更改代码。
例如，假设您有一个管理专业资料和社交关系的应用程序。 如果要向应用程序添加新功能，则需要能够更新Canister代码而不丢失任何先前存储的数据。 Canister升级使您可以通过程序更改来更新现有标识符，而不会丢失程序状态。
请注意，要在升级用Motoko编写的Canister时保留状态，请确保使用stable关键字来标识要保留的变量。有关在Motoko中保留变量状态的更多信息，请参阅稳定变量和升级方法。如果要升级用Rust编写的Canister，则应使用Rust CDK示例中所示的pre_upgrade和post_upgrade函数，以确保在Canister升级后可以正确保留数据。
在Internet Computer网络上升级Canister：
打开一个终端并进入项目目录
如有必要，启动Internet Computer网络
多数情况下，仅当您在本机运行Internet Computer网络，才需要执行该步骤
如果要在远程网络上升级Canister，则应包括--network命令行选项，以在该网络上执行任务。
确认您具有要升级的所有Canister的标识符。
请注意，您的程序必须使用变量声明中的stable关键字来标识要为其维护状态的变量。
有关声明稳定变量的更多信息，请参见《 Motoko编程语言指南》。
运行以下命令升级所有Canister：
dfx canister install --all --mode upgrade
删除Canister
如果要在Internet Computer网络上永久删除特定的Canister或特定项目的所有容器，可以通过运行dfx canister delete命令来执行。
删除Canister会从Internet Computer网络中删除Canister标识符，代码和状态。 但是，在删除之前，必须先停止Canister以清除所有未决的消息请求或应答。
删除本地Internet Computer网络上运行的一个项目的所有Canister：
打开一个终端并进入项目目录
如有必要，启动Internet Computer网络
多数情况下，仅当您在本机运行Internet Computer网络，才需要执行该步骤
如果要在远程网络上删除Canister，则应包括--network命令行选项，以在该网络上执行任务。
运行以下命令，检查项目Canister运行状态：
dfx canister status --all
运行以下命令停止项目所有Canister：
dfx canister stop --all
运行以下命令删除项目所有Canister：
dfx canister delete --all

故障排除
本部分提供的信息可帮助您定位和解决与以下任务相关的常见问题：
下载并安装DFINITY Canister SDK
创建，构建或部署Canister
使用dfx命令行接口
在本地开发环境中运行Internet Computer网络
确保nodejs在项目中可用
由于项目依赖于webpack为默认的前端提供框架，因此您必须在开发环境中安装node.js并在项目目录中可访问。
如果要在不使用默认Webpack配置和Canister别名的情况下开发项目，则可以从dfx.json文件中删除资源Canister，也可以使用特定的Canister名称来构建项目。 例如，您可以通过运行以下命令来选择仅构建没有前端资源的hello程序：
dfx build hello
如果您使用默认的Webpack配置并且运行dfx build失败，则应尝试在项目目录中运行npm install，然后重新运行dfx build。
如果在项目目录中运行npm install没有解决问题，则应检查webpack.config.js文件的配置是否存在语法错误。
迁移现有项目
当前，对于使用早期版本的dfx命令行接口创建的任何项目，都没有自动迁移或向后兼容性。 升级到最新版本后，如果尝试构建或安装使用dfx命令行接口的早期版本创建的项目，则可能会看到错误或失败消息。
但是，在许多情况下，您可以通过手动更改dfx.json配置文件中的dfx设置，然后重建项目以使其与您拥有的dfx命令行界面版本兼容。
例如，如果您有一个使用dfx版本0.4.9创建的项目，请在文本编辑器中打开dfx.json文件，并将dfx设置更改为最新版本或完全删除该部分。
重启本地Internet Computer网络
在某些情况下，由于复制状态错误，在本地启动Internet Computer网络失败。如果在运行dfx start时遇到问题：
在显示网络操作的终端中，按Control-C中断本地网络进程。
运行以下命令停止本地Internet Computer网络：
dfx stop
运行以下命令，以纯净状态重新启动Internet Computer：
dfx start --clean
--clean选项从项目的缓存中删除检查点和过时的状态信息，以便您可以在纯净状态下重新启动Internet Computer副本和Web服务器进程。
但是请记住，如果通过运行dfx start --clean重置状态信息，那么现有Canister也将被删除。
运行dfx start --clean之后，运行以下命令来重新创建Canister：
dfx canister create --all
dfx build
dfx canister install --all
删除Canister目录
如果在成功连接到Internet Computer并注册Canister标识符后遇到构建或部署的问题，则应在尝试重建或重新部署之前删除Canister目录。
通过在项目的根目录中运行以下命令来删除项目的Canister目录：
rm -rf ./.dfx/* canisters/*
重新安装dfx
您可能会遇到的许多错误都可以通过卸载并重新安装dfx命令行界面来解决。 这是重新安装dfx的几种方法。
如果在开发环境中仅安装了一个版本的dfx，通常可以运行以下命令来卸载并重新安装最新版本的dfx：
~/.cache/dfinity/uninstall.sh && sh -ci "$(curl -sSL https://sdk.dfinity.org/install.sh)"
如果您已经修改了dfx二进制文件的位置，则可能需要运行以下命令来卸载PATH中的dfx版本，然后重新安装最新版本的dfx：
rm -rf ~/.cache/dfinity && rm $(which dfx) && sh -ci "$(curl -sSL https://sdk.dfinity.org/install.sh)"
Xcode先决条件
在macOS计算机上创建新项目时，某些版本的DFINITY Canister SDK会提示您安装Xcode。 该提示已删除，并且dfx new命令不需要您安装任何macOS开发工具。 但是，如果要为项目创建Git存储库，则应安装Developer Command Line Tools。
您可以通过运行xcode-select -p来检查是否安装了开发工具。 您可以通过运行xcode-select --install来安装开发工具。
使用虚拟机时构建失败
如果您在Ubuntu或CentOS上使用虚拟机运行dfx，则当您尝试运行dfx build命令时，可能会看到一条错误消息，如下所示：
Building hello...
An error occurred:
Io(
    Os {
        code: 2,
        kind: NotFound,
        message: "No such file or directory",
    },
)
处理孤立进程
dfx工具运行多个进程。 有时进程无法正确终止。 如果怀疑或者收到进程已经在后台运行的消息，请运行以下命令：
pkill replica nodemanager dfx
内存泄露
解决内存泄漏是一个持续的过程。 如果遇到与内存泄漏有关的任何错误消息，则应执行以下操作：
运行dfx stop以停止当前正在运行的进程。
卸载dfx以防止进一步恶化。
重新安装dfx。
运行dfx start重新启动副本进程。
或者，您可以删除.cache/dfinity目录，然后重新安装最新的dfx二进制文件。例如：
rm -rf ~/.cache/dfinity && sh -ci "$(curl -sSL https://sdk.dfinity.org/install.sh)"
四、教程
探索默认项目
     如果你在快速开始章节体验过 DFINITY 容器 SDK，那你已经熟悉了 ICP 创建应用的基本工作流程。现在，让我们通过探索新项目中默认创建的文件来深入了解工作流程。
    下面的图片描述了在本地运行 ICP 进行开发的工作流程。
图片: https://uploader.shimo.im/f/BZVur2lZrAbHAdFj.png
开始前的准备
    开始本教程前，请检查下面的步骤是否完成了
有一台有网络连接的 macOS 或 Linux 电脑
安装了 node.js（如果需要包含前端开发的默认模板文件）
下载并安装了 DFINITY 容器 SDK（参考下载与安装章节）
如果你使用的是 VsCode 作为 IDE，请确认安装了 Motoko 的 VSCode 插件（参考安装语言编辑器插件章节）
本地电脑上没有运行 ICP 网络进程
创建新项目
    创建新项目需要用到 dfx 命令
    创建新项目步骤如下
打开终端
进入工作目录
运行下面的命令来创建项目
dfx new explore_hello
这条命令会创建一个新的 explore_hello 项目，包含一个默认的项目目录结构，同时会初始化为一个 git 仓库。如果安装了 node.js，还会包含前端代码和相关依赖
为了保证兼容性，项目名称只能使用字母和下划线。
运行下面的命令查看默认目录结构
      ls -l explore_hello
      项目目录结构中默认包含至少一个 src 子目录，一个模板 README.md 文件和一个默认的 dfx.json 配置文件
      如果安装了 node.js，项目目录下会包含以下文件
      explore_hello/
├── README.md      # default project documentation
├── dfx.json       # project configuration file
├── node_modules   # libraries for front-end development
├── package-lock.json
├── package.json
├── src            # source files directory
|   └── explore_hello
│       ├── main.mo
│       └── public
│           └── index.js
└── webpack.config.js
     默认项目目录包含以下文件
默认的 README 文件，用于项目说明
默认的 dfx.json 配置文件，用于项目配置
默认的 src 目录，存放应用源码文件
    默认的 src 目录包含模版文件 main.mo，你可以修改来包含核心程序逻辑
    这个教程内容很基础，只需要用到 main.mo 文件。如果安装了 node.js，项目目录会包含应用前端相关的文件和目录。前端开发和 public 目录下的模板文件会在后续教程中解释。
默认配置
    检查默认配置步骤如下
打开命令行
进入项目目录
cd explore_hello
在编辑器中，打开 dfx.json 配置文件
{
  "canisters": {
    "explore_hello": {
      "main": "src/explore_hello/main.mo",
      "type": "motoko"
    },
    "explore_hello_assets": {
      "dependencies": [
        "explore_hello"
      ],
      "frontend": {
        "entrypoint": "src/explore_hello_assets/public/index.js"
      },
      "source": [
        "src/explore_hello_assets/assets",
        "dist/explore_hello_assets/"
      ],
      "type": "assets"
    }
  },
  "defaults": {
    "build": {
      "packtool": ""
    }
  },
  "dfx": "0.6.26",
  "networks": {
    "local": {
      "bind": "127.0.0.1:8000",
      "type": "ephemeral"
    }
  },
  "version": 1
}
默认配置
canisters 字段指定项目的 WebAssembly 模块名称为 explore_hello
canisters.explore_hello 中的 main 字段指定被编译的 main 程序文件路径，这里是 src/explore_hello/main.mo，type 字段指定语言类型，这里是 motoko
canisters.explore_hello_assets 字段指定项目的前端资源信息
dfx 配置被用来指定创建项目的软件版本
netowrks 字段指定连接的网络信息。默认配置会将 ICP 网络绑定到本地地址 127.0.0.1，端口 8000。
         如果可以访问其他 ICP 网络提供商，可以在 networks 字段中包含相关的 URL 来连接。
关闭 dfx.json 文件继续
默认程序代码
新项目会包含一个 main.mo 模板源码文件。通过编辑这个文件包含你的代码来加速开发。
接下来以 main.mo 模版文件为例来学习使用 Motoko 编程语言。
在项目目录下运行命令
pwd
编辑器中打开 src/explore_hello/main.mo 文件查看模板代码
actor {
    public func greet(name : Text) : async Text {
        return "Hello, " # name # "!";
    };
};
这段程序有几个元素
示例代码定义了 actor 而不是常见的 main 函数，对于 Motoko，main 函数已经隐式地包含在文件里了。
虽然常见的“Hello，World！”程序描述了如何使用 print 或 println 函数打印字符串，但是一般的程序无法展示 Motoko 在 ICP 上如何使用。
这段示例代码定义了一个 actor，包含一个公共的 greet 函数，greet 函数接收一个 Text 类型的 name 参数。
程序使用 async 关键字指定程序返回一个异步文本消息，该消息通过#操作符拼接，由 “Hello，”，name 参数和“！”组成。
之后会深入介绍如何使用 actor 对象和异步消息处理。
关闭 main.mo 继续
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端
注册 Canister 识别码
连接到本地开发 ICP 网络后，可以为项目注册一个网络中唯一的 Canister 识别码。
在快速开始章节中，这一步会在 dfx deploy 命令中执行。这片教程演示如何独立执行这些命令。
在本地网络注册 Canister 识别码步骤：
进入项目根目录
运行下面的命令注册 Canister 识别码
dfx canister create --all
命令会显示定义在 dfx.json 配置文件里的 Canster 在本地网络唯一的 Canister 识别码。
Creating canister "explore_hello"...
"explore_hello" canister created with canister id: "rwlgt-iiaaa-aaaaa-aaaaa-cai"
Creating canister "explore_hello_assets"...
"explore_hello_assets" canister created with canister id: "rrkah-fqaaa-aaaaa-aaaaq-cai"
如果你连接的是本地开发 ICP 网络，这些 Canister 识别码只在本地有效，并存储在项目的.dfx/local/canister_ids.json 文件。
文件内容示例：
{
  "explore_hello": {
    "local": "rwlgt-iiaaa-aaaaa-aaaaa-cai"
  },
  "explore_hello_assets": {
    "local": "rrkah-fqaaa-aaaaa-aaaaq-cai"
  }
}
项目构建
在了解了默认配置和代码并启动好本地 ICP 网络后，接下来学习如何把示例程序编译为可执行的 WebAssembly 模块
构建步骤：
在命令行中进入 explore_hello 项目目录。
运行下面的命令
dfx build
输出信息如下
Building canisters...
Building frontend...
dfx build 命令会在项目的.dfx/local/目录下添加 canisters 目录
运行下面的命令检查 dfx build 命令创建的 .dfx/local/canisters/explore_hello 目录包含 WebAssembly 和相关应用文件。
ls -l .dfx/local/canisters/explore_hello/
 命令输出
-rw-r--r--  1 pubs  staff     43 Jul 21 12:18 explore_hello.did
-rw-r--r--  1 pubs  staff    103 Jul 21 12:18 explore_hello.did.js
-rw-r--r--  1 pubs  staff    174 Jul 21 12:18 explore_hello.js
-rw-r--r--  1 pubs  staff  95905 Jul 21 12:18 explore_hello.wasm
canisters/explore_hello 目录包含如下关键文件：
explore_hello.did 文件包含 main 程序的接口描述
The explore_hello.did.js 文件包含用 JavaScript 描述的程序 Canister 函数接口
The explore_hello.js 文件包含用 JavaScript 描述的程序 Canister 接口
The explore_hello.wasm 包含编译后的 WebAssembly
canisters/explore_hello_assets 目录包含相似的文件，用于描述项目的前端资源。 
除了这些目录，dfx build 命令还会创建 idl 目录。
    
本地项目部署
部署程序到 ICP 网络需要 WebAssembly 模块和 canister_manifest.json 文件
部署步骤：
进入项目目录
运行命令
dfx canister install --all
 命令输出
Installing code for canister explore_hello, with canister_id rwlgt-iiaaa-aaaaa-aaaaa-cai
Installing code for canister explore_hello_assets, with canister_id rrkah-fqaaa-aaaaa-aaaaq-cai
运行下面的命令调用程序相关函数
dfx canister call explore_hello greet everyone
命令参数
explore_hello 调用的 Canister 名称或应用服务
greet 调用的方法
everyone 传给 greet 函数的参数
命令会显示 greet 函数的输出
("Hello, everyone!")
查看默认的前端
如果开发环境安装了 node.js，那么项目中会包含一个简单的前端示例，示例中的JavaScript模板脚本index.js会在浏览器中对接explore_hello程序。
前端模板部署步骤
打开命令行，进入项目目录
打开src/explore_hello_assets/public/index.js文件，查看代码
import explore_hello from 'ic:canisters/explore_hello';

explore_hello.greet(window.prompt("Enter your name:")).then(greeting => {
  window.alert(greeting);
});
模板文件index.js使用DOM描述Web文档的结构和内容
示例文件倒入创建的Canister并在一个提示框中调用greet函数。
关闭index.js文件继续
查看自动创建的前端资源文件
ls -l .dfx/local/canisters/explore_hello_assets/
 命令输出示例
drwxr-xr-x  9 pubs  staff     288 Apr  6 14:25 assets
-r--r--r--  1 pubs  staff    2931 Dec 31  1969 assetstorage.did
-r--r--r--  1 pubs  staff  265823 Dec 31  1969 assetstorage.wasm
-rw-r--r--  1 pubs  staff    3651 Apr  6 14:25 explore_hello_assets.d.ts
-rw-rw-rw-  1 pubs  staff    2931 Dec 31  1969 explore_hello_assets.did
-rw-r--r--  1 pubs  staff    4236 Apr  6 14:25 explore_hello_assets.did.js
-rw-r--r--  1 pubs  staff     149 Apr  6 14:25 explore_hello_assets.js
-rw-rw-rw-  1 pubs  staff  265823 Dec 31  1969 explore_hello_assets.wasm
这些文件是使用node模块和index.js文件由 dfx build命令自动生成的
打开浏览器，进入在dfx.json中配置的网址127.0.0.1:8000
按下面到格式添加canisterId 参数和explore_hello_assets 容器识别码到URL
?canisterId=<YOUR-CANISTER-IDENTIFIER>
完整路径示例
http://127.0.0.1:8000/?canisterId=rrkah-fqaaa-aaaaa-aaaaq-cai
Note: canisterId参数是大小写敏感的
查看HTML页面
图片: https://uploader.shimo.im/f/SqaamEobCNY6oqLM.png
点击Click Me来调用greeting函数
图片: https://uploader.shimo.im/f/bUUPzekV5RNFgNQ0.png

关闭本地网络
体验完项目后，可以关闭本地ICP网络
停止本地网络步骤
在显示网络操作命令行内, 按下Control - C终止本地网络进程
运行下面到命令停止
dfx stop
 
使用actor查询
在快速开始章节中，已经了解过一个使用了actor对象和异步消息的简单应用。接下来的教程中，会写一个使用基于actor的消息的应用。本篇教程会讲解如何修改Hello，World！应用来定义一个actor并在本地网络部署测试。
开始之前
开始前，需要检查下面的问题
已经按照下载与安装章节的步骤下载并安装了DFINITY Canister SDK
本地电脑上已经关闭了ICP网络进程
本篇教程需要大概20分钟
创建新项目
创建项目步骤
打开终端
进入工作目录
运行下面的命令来创建项目
dfx new actor_hello
进入项目目录
cd actor_hello
修改默认配置
在探索默认项目章节，已经介绍了创建新项目会添加一个dfx.json配置文件到项目目录。在本章节中，需要修改一些默认配置。
dfx.json配置修改步骤
在编辑器中，打开 dfx.json 配置文件
查看actor_hello项目中的默认配置
注意源码的名称和路径以及输出文件都使用actor_hello项目名称。
例如，默认的canister名称是actor_hello并且默认的主程序路径是
src/actor_hello/main.mo。
这些文件和目录可以重命名，但是要确保这些文件和目录的名称和dfx.json配置文件中的一
致。如果使用默认的目录和文件名称，则无需修改。
删除所有的actor_hello_assets配置
本章节的示例程序无需使用如何前端资源，因此可以删除这些配置。
以下是删除actor_hello_assets配置后的示例配置
{
  "canisters": {
    "actor_hello": {
      "main": "src/actor_hello/main.mo",
      "type": "motoko"
    }
  },
  "defaults": {
    "build": {
      "packtool": ""
    }
  },
  "dfx": "0.6.26",
  "networks": {
    "local": {
      "bind": "127.0.0.1:8000",
      "type": "ephemeral"
    }
  },
  "version": 1
}
保存并关闭配置文件继续
修改默认程序
在探索默认项目章节，已经介绍了创建新项目会创建一个默认的src目录，并包含一个main.mo程序模板文件。在本章节中，可以修改模板代码创建一个简单的使用actor的"Hello, World!"程序
源码修改步骤
进入项目目录
cd src/actor_hello
编辑器中打开main.mo文件
接下来会编写一个可以输出"Hello, World!"的示例程序。为了编译后的程序在ICP上运行，程序必须包含一个有public函数的actor对象。
复制粘贴以下示例代码到main.mo文件
import Debug "mo:base/Debug";
actor HelloActor {
   public query func hello() : async () {
      Debug.print ("Hello, World from DFINITY \n");
   }
};
代码解析
程序导入Debug模块来提供print功能
程序使用public query func来定义一个查询方法，在这个方法中，actor_hello程序不会对canister状态进行修改或执行更新数据的操作。
要获取有关查询调用的信息，请查看Canisters include both program and state的query 
calls章节
使用本地识别码构建应用
如果你只需要对这个简单程序做本地测试，那么，就不需要再ICP网络为这个程序的编译输出保留一个单独的Canister识别码。
在本节中，可以无需连接ICP网络来编译程序。dfx build命令可以创建一个本地硬编码的canister识别码。
测试程序时，在无需本地启动或连接ICP网络的情况下，你都可以使用这个本地识别码。
构建程序执行文件步骤
进入项目目录
使用本地识别码构建程序命令
dfx build --check
--check 参数可以查看本地构建项目时编译和输出文件的日志。dfx build --check 命令只
会生成一个临时的识别码，你将看到以下内容
Building canisters to check they build ok. Canister IDs might be hard coded.
Building canisters...
如果程序成功编译，可以
在.dfx/local/canisters 和 .dfx/local/canisters/actor_hello/  查看输出的
文件。
比如，使用tree命令查看创建的文件
tree .dfx/local/canisters
 命令输出
.dfx/local/canisters
├── actor_hello
│   ├── actor_hello.d.ts
│   ├── actor_hello.did
│   ├── actor_hello.did.js
│   ├── actor_hello.js
│   └── actor_hello.wasm
└── idl

2 directories, 5 files


部署项目
dfx build --check 命令不会部署到任何ICP网络。如果要部署本项目，需要做以下步骤
连接ICP网络
注册网络Canister识别码
部署Canister
在部署项目前，必须了解到本地运行或远程的ICP网络。连接到ICP网络后，必须生成一个独一无二，网络绑定的Canister识别码来替换本地定义的识别码。
本地部署步骤
打开命令行，进入项目目录
启动本地ICP网络
dfx start --background
 本教程中，使用--background 选项启动在后台启动ICP网络。使用这个选项后，你可以继续输入命令无需打开另一个命令行窗口。
使用下面的命令为项目在本地ICP网络生成一个新的Canister识别码
dfx canister create actor_hello
 输出下面的内容
Creating a wallet canister on the local network.
The wallet canister on the "local" network for user "pubs-id" is "rwlgt-iiaaa-aaaaa-aaaaa-cai"
Creating canister "actor_hello"...
"actor_hello" canister created with canister id: "rrkah-fqaaa-aaaaa-aaaaq-cai"

dfx canister create 命令会存储网络绑定的canister识别码到.dfx/local目录下的
canister_ids.json文件
例如
{
  "actor_hello": {
    "local": "rrkah-fqaaa-aaaaa-aaaaq-cai"
  }
}
使用下面的命令在本地ICP网络部署actor_hello 项目
dfx canister install actor_hello
 命令输出
Installing code for canister actor_hello, with canister_id rrkah-fqaaa-aaaaa-aaaaq-cai
查询Canister
现在，项目已经部署到本地ICP网络，并且可以使用dfx canister call命令进行测试。
测试部署的程序步骤如下
使用dfx canister call命令调用hello函数
dfx canister call actor_hello hello
验证hello函数在本地网络进程中输出了相应的检查消息
例如，程序会输出类似以下内容
[Canister rrkah-fqaaa-aaaaa-aaaaq-cai] Hello, World from DFINITY
注意"Hello, World from DFINITY" 只会出现在显示本地ICP网络活动的命令行中。
关闭本地网
完成程序的测试后，可以关闭ICP网络
关闭步骤
打开显示网络活动的命令行，摁下Control-C命令终止本地网络进程
运行下面的命令终止网络
dfx stop

传递文本参数
本章节会演示如何对默认程序进行简单的修改，来支持传递一个文本参数到一个actor，并编译创建canister获取参数。
本章节讲解了如何在命令行中使用Candid接口描述语言（IDL）传递参数以及如何修改程序允许其接受多个文本参数。
开始之前
开始前，需要检查下面的问题
已经按照下载与安装章节的步骤下载并安装了DFINITY Canister SDK
本地电脑上已经关闭了ICP网络进程
本篇教程需要大概20分钟

创建新项目
创建项目步骤
打开终端
进入工作目录
运行下面的命令来创建项目
dfx new location_hello
进入项目目录
cd location_hello
修改默认配置
在探索默认项目章节，已经介绍了创建新项目会添加一个dfx.json配置文件到项目目录。在本章节中，需要修改一些默认配置。
dfx.json配置修改步骤
在编辑器中，打开 dfx.json 配置文件
查看actor_hello项目中的默认配置
删除所有的location_hello_assets配置
本章节的示例程序无需使用如何前端资源，因此可以删除这些配置。
保存并关闭配置文件继续
修改默认程序
在探索默认项目章节，已经介绍了创建新项目会创建一个默认的src目录，并包含一个main.mo程序模板文件。
源码修改步骤
编辑器中打开src/location_hello/main.mo 源码文件
修改默认源码，用有city参数的location函数替换greet函数
例如
actor {
  public func location(city : Text) : async Text {
    return "Hello, " # city # "!";
  };
};
保存并关闭文件
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端
注册构建并部署应用
在开发环境中连接到本地ICP网络后，就可以在本地注册构建部署应用了。
部署应用步骤
检查是否在项目根目录
注册构建并部署应用命令
dfx deploy
dfx deploy命令会输出执行的操作信息
传递文本参数
现在，项目已经部署到本地ICP网络，并且可以使用dfx canister call命令进行测试。
测试部署的程序步骤如下
运行下面命令来调用程序的location 方法并传递文本类型的city参数
dfx canister call location_hello location "San Francisco"
由于参数San和Francisco之间包含一个文本
运行下面命令来调用程序的location 方法并显式地使用Candid接口描述语言规则来传递文本类型的city参数
修改程序源码
在浏览器中测试函数
关闭本地网
自然数自增
开始之前
创建新项目
修改默认配置
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
在部署的Canister中调用方法
在浏览器中测试函数
关闭本地网

计算函数中使用整数
开始之前
创建新项目
修改默认配置
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
在Canister中验证计算函数
在浏览器中测试函数
关闭本地网

库模块导入

开始之前
创建新项目
修改默认配置
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
使用insert函数添加名字和数字
在浏览器中测试函数
关闭本地网

使用多个actor
开始之前
创建新项目
修改默认配置
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
调用函数验证部署
在浏览器中测试函数
关闭本地网

自定义前端

开始之前
创建新项目
修改默认配置
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
查看前端
修改前端并测试
关闭本地网

添加前端样式

开始之前
创建新项目
修改默认配置
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
修改样式并测试
修改前端或后端代码
在浏览器中测试函数
关闭本地网

使用私有canister调用
开始之前
下载Demo
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册canister识别码
构建并部署demo项目
创建资料并连接
探索配置文件
探索连接的源代码
探索Linkedup源代码
关闭本地网

创建可扩展app
分割上传的内容到多个Canister
互操作性演示
认证模型
接入前端特性
数据模型一览
添加访问控制
开始之前
创建新项目
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
检查当前的认证内容
创建新用户识别码
分配一个角色到识别码
添加一个已认证用户识别码
为多个命令设置用户识别码
关闭本地网
更多内容

从钱包接收cycles
开始之前
创建新项目
修改默认程序
启动本地网络
开始构建项目前，需要连接到本地或远程 ICP 网络。
启动本地网络需要 dfx.json 文件，需要确认在项目根目录操作。在这篇教程中，建议开启 2 个终端，一个启动网络，另一个管理项目。
启动网络步骤
打开新的终端
进入项目根目录
使用下面的命令启动 ICP 本地网络
dfx start
这是可能会有警告信息显示，这取决于使用的平台安全策略配置。这时请选择允许。
启动本地网络后，终端会显示网络操作信息。
切换到项目终端

注册构建并部署应用
测试应用
关闭本地网
更多内容




五 、参考资料
 命令行参考
The DFINITY command-line execution environment (dfx) is the primary tool for creating, deploying, and managing the applications you develop for the Internet Computer platform.
You can use the dfx parent command with different flags and subcommands to perform different types of operations.
The basic syntax for running dfx commands is:
DFINITY命令行执行环境（dfx）是用于创建，部署和管理您为Internet计算机平台开发的应用程序的主要工具。

您可以将带不同标志dfx父命令和子命令一起使用以执行不同类型的操作。
dfx [option] [subcommand] [flag]
copy

Depending on the subcommand, the options and flags you specify might apply to the parent command or to a specific subcommand. For example, the flags for enabling or suppressing verbose logging are specified for the dfx parent command, then applied to any subcommands.
When you have the DFINITY Canister SDK installed, you can use the following commands to specify the operation you want to perform. For reference information and examples that illustrate using these commands, select an appropriate command.
dfx
dfx bootstrap
dfx build
dfx cache
dfx canister
dfx config
dfx deploy
dfx help
dfx identity
dfx new
dfx ping
dfx replica
dfx start
dfx stop
dfx upgrade
六、 语言 
语言和API参考

语言和 API 参考信息是提供给高级程序员或系统架构师使用的，他们需要更多的关于这些支持高级开发者工具的底层结构、库和模块的详细信息。

Motoko
Motoko 语言导引
Motoko 基础语言库
Motoko 语言快速参考

Candid
Candid 导引
Candid 规范
Candid 箱子

Rust
Rust 入门介绍
互联网计算机类型库(ic-types)
互联网计算机代理库(ic-agent)
互联网计算机 Canister 开发套件（(ic-cdk）
Rust Canister 开发套件（CDK）示例

Candid

这是提供给应用程序开发者的 Candid 文档，欢迎阅读。

本“Candid 导引”解释了什么是 Candid，也解释了如何使用它来开发在互联网计算机上运行的程序。这里的信息主要是面向希望在互联网计算机上部署“Canisters”的后端和前端开发者。 如果您想实现对一种新语言的支持或扩展现有的 Candid 特性，您应该参考正式的 Candid 规范以获得关于该语言内部结构的背景信息和细节。

“什么是 Candid？” 这一节介绍了 Candid 接口描述语言的目的和主要功能。 它概述了 Candid 的工作原理，并提供了一些简单的示例，使您对如何将 Candid 用于你的应用有一定的了解。

“How to”这一节解释了如何执行典型任务。

“参考”这一节提供了 Candid 工具和库的链接，以及有关 Candid 支持的类型的详细参考信息。

什么是Candid？
Candid是一种接口描述语言。它的主要目的是来描述Service（服务）的公共接口，通常表现为运行在互联网计算机的Canister的程序。Candid的主要优点之一是它与编程语言无关，并且允许使用不同编程语言（包括Motoko，Rust和JavaScript）来编写Service与前端之间进行交互操作的程序。
Candid中的典型接口描述可能如下所示：
service counter : {
  add : (nat) -> ();
  subtract : (nat) -> ();
  get : () -> (int) query;
  subscribe : (func (int) -> ()) -> ();
}

在这个例子中，命名为counter（计数器） 的service（服务），包含了以下的公共方法（method）：

-	Add方法和subtract方法改变counter的值。
-	Get方法读取了Counter的当前数值
-	Subscribe方法可用于调用另一个函数，例如，每次Counter的值更改时调用"通知回复"方法。
如本示例所示，每个方法（method）都有一系列参数和结果类型。 方法（method）还包括用于特定于互联网计算机的Annotations（注释）， 如本示例中所示的query（查询）。
有了这个简单的接口描述，您就可以直接从命令行或通过基于Web的前端或通过Rust程序以编程方式或通过另一种编程或脚本语言调用Counter这个service（服务）。
除了互操作性之外，Candid还可以通过精确识别哪些变更可以执行并且不破坏现有客户数据，来支持服务接口的升级。 例如，您可以安全地向Service（服务）添加新的可选参数，而不会失去与现有客户端的兼容性。

为什么创建新的IDL？
第一眼看到这个的时候，你也许会想其他的语言，例如JSON，XML，或者Protobuf，已经足够了。然而，Candid拥有一个独特的融合特点，是这些技术所没有的。这个特点让Candid特别适合开发运行在互联网计算机上的应用，包括如下：
  JSON，XML和Protobuf等许多语言仅描述如何将单个值映射到字节或字符。这些数据描述语言无法整体描述service（服务）的内容。 这些语言专注于要传输的数据类型，而不是使用这些数据类型的方法。
 Candid实现将Candid值直接映射到Host语言的类型和值。 使用Candid，程序员无需构造或解构某些抽象的Candid值。
 Candid定义了有关如何以合理且有条理的方式升级服务及其接口的规则。
 Candid本质上是一种高级语言。 使用Candid，您不仅可以传递纯数据，还包括对服务和方法的引用。 Candid支持更高级别的安全升级。
Candid内置了支持互联网计算机的功能，例如query 

Candid 类型和值
Candid是一个强类型的系统，具有一组规范地涵盖大多数用途的类型。 它有：
无界整数类型（nat, int）
有界整数类型(nat8, nat16, nat32, nat64, int8, int16, int32, int64)
浮点类型(float32, float64)
布尔类型（bool）
文本（text）和二进制（blob）数据的类型
容器类型，包括变量（opt，vec，record，variant）
引用类型（service, func, principal）
特殊的空值，保留和空类型
所有类型均在“参考”这一章中进行了详细描述
这组类型背后的理念是，它们能充分描述数据的结构，因此可以对信息进行编码，传递和解码，但有意不描述超出描述所需要的语义约束。 例如，无法表达数字应该是偶数，向量具有一定的长度或向量的元素已排序。

Candid的service（服务）描述
如果你熟悉了Candid类型，就可以使用它们来描述service（服务）。  Candid的service描述文件（.DID文件）可以手工编写，也可以从service执行中生成。
在探索如何为特定host语言生成service（服务）描述之前，让我们仔细研究一下service例子的描述的结构及其组成部分。
最简单的service描述是没有公共method（方法）的service，如下所示：

service : {}

这个service并没有什么功能，所以让我们增加一个简单的method，ping进去。

service : {
  ping : () -> ();
}

这个例子说明了一个service支持一个名称为ping的公共method（方法）。Method的名称可以是任意字符串，并且如果它们不是纯标识符，则可以将它们前后加上引号（“method with space”）。
Method声明了参数和结果类型的序列。 这个ping，不传递任何参数且不返回任何结果，因此空序列`（）`既用于参数又用于结果。
现在，您已经看到了最简单的例子，让我们考虑一个稍微复杂的service（服​​务）描述。 该服务由两个method（方法）-reverse和-divMod组成，每个方法都包含一系列参数和结果类型：
service : {
  reverse : (text) -> (text);
  divMod : (dividend : nat, divisor : nat) -> (div : nat, mod : nat);
}

方法reverce 需要输入一个text类型的参数，并返回一个text类型的值。
divMod方法需要输入两个均为nat类型的参数，并返回两个均为nat类型的值。

命名参数和结果
在前面的示例中，divMod方法的签名包括了参数和返回值的名称。 给某个method（方法）的参数或结果命名纯粹是出于文档目的。 您使用的名称不会更改方法的类型或所传递的值。 取而代之的是，参数和结果通过其位置来标识，而与名称无关。
特别地，Candid不会阻止您将类型更改为：
  divMod : (dividend : nat, divisor : nat) -> (mod : nat, div : nat);

或将上面的divMod传递给需要首先返回值为mod的一种method（方法）的service（服务）。
因此，这与语义上相关的命名记录字段有很大不同。

Motoko 编程语言

重要
Motoko 编程语言将随着 DFINITY Canister SDK 的每个版本的更新和 Motoko 编译器的更新而不断发展。定期查看更新内容，并尝试新的功能。

Motoko 编程语言是一种新的、现代的、可靠的编程语言，专为希望构建可以直接在互联网计算机上运行的下一代应用程序和服务上的开发人员而设计。Motoko 是专门设计来支持互联网计算机的独特功能，并提供一个熟悉但强大的编程环境。作为一种新的语言，Motoko 不断进化以支持新特性和不断改进。 请保持跟踪 Motoko 的更新和开源项目的公告。

原生支持 Canister

Motoko 原生支持互联网电脑的“Canister”，这些“Canister”用 actors 来表示，是指封装了其状态，并采用异步通讯的具有自治对象。
actor Counter {

  var value = 0;

  public func inc() : async Nat {
    value += 1;
    return value;
  };
}

 
顺序式结构编程
 
在互联网计算机上，Canister调用其他的Canister是异步的, 但是Motoko语言可以让你顺序式结构对系统进行编程。调用函数返回的未来的值是异步信息，await架构可以将这些函数调用链接起来，就像他们是同步的一样。
actor Factorial {

  var last = 1;

  public func next() : async Nat {
    last *= await Counter.inc();
    return last;
  }
};

ignore await Factorial.next();
ignore await Factorial.next();
await Factorial.next();

现代型系统

Motoko 对于熟悉 Javascript 和其他流行的语言的人来说是没有障碍的，并且提供了先进的功能，比如可靠性，通用性，可变性和模型匹配。

type Tree<T> = {
  #leaf : T;
  #branch : {left : Tree<T>; right : Tree<T>};
};

func iterTree<T>(tree : Tree<T>, f : T -> ()) {
  switch (tree) {
    case (#leaf(x)) { f(x) };
    case (#branch{left; right}) {
      iterTree(left, f);
      iterTree(right, f);
    };
  }
};

// Compute the sum of all leaf nodes in a tree
let tree = #branch { left = #leaf 1; right = #leaf 2 };
var sum = 0;
iterTree<Nat>(tree, func (leaf) { sum += leaf });
sum

自动生成 IDL 文件

SDK 会以一种称为 Candid 的语言中性格式导出您的接口定义。因此，其他具有权限的 Canister，浏览器驻留的代码和智能手机应用程序都可以调用您的函数。Motoko 编译器还可以读取和写入接口定义文件，从而允许 Motoko 与使用其他语言编程的容器无缝交互。
例如前面的 命名为 Counter（计数器） 的 actor ( 罐子 Canister), 会产生下面这个 Candid IDL：
service Counter : {
  inc : () -> (nat);
}


永久独立保存

Internet 计算机会保留运行容器的内存页面。 因此，Actor 的状态及其所有内存数据结构会无限期地存活，因此无需特地“保存”它们。
例如，在这个为文本名称分配顺序 ID 的注册表服务中，即使在多个节点之间复制 Canister 的状态，并且不驻留在内存中，哈希表的状态也会在调用之间保留。

import Text "mo:base/Text";
import Map "mo:base/HashMap";

actor Registry {

  let map = Map.HashMap<Text, Nat>(10, Text.equal, Text.hash);

  public func register(name : Text) : async () {
    switch (map.get(name)) {
      case null {
        map.put(name, map.size());
      };
      case (?id) { };
    }
  };

  public func lookup(name : Text) : async ?Nat {
    map.get(name);
  };
};

await Registry.register("hello");
(await Registry.lookup("hello"), await Registry.lookup("world"))

更新

Motoko 提供了许多功能来帮助您利用永久独立保存，其中包括一些语言功能，这些功能可以在升级容器软件时使堆自动迁移。
例如，Motoko 允许您将某些变量声明为稳定变量。 稳定变量的值会在软件升级过程中自动保留。

看一下这个定义为stable（稳定）的Counter（计数器）：
actor Counter {

  stable var value = 0;

  public func inc() : async Nat {
    value += 1;
    return value;
  };
}

它被安装后，在数值递增了 n 次后，不需要中断就可以升级增加更多命令：
actor Counter {

  stable var value = 0;

  public func inc() : async Nat {
    value += 1;
    return value;
  };

  public func reset() : async () {
    value := 0;
  }
}

因为数值被定义为 stable，因此升级后将保留计数器的当前状态 n。 计数将从 n 开始，而不是从 0 重新开始。
因为新界面与先前界面兼容，所以引用该服务的现有客户端将继续工作，但是新客户端将能够利用其升级功能（附加的重置功能）。

对于仅靠稳定变量无法解决的情况，Motoko 提供了用户可定义的升级挂钩，在升级之前和之后立即运行，并允许您将任意状态迁移到稳定变量。

还有更多...

Motoko 提供了许多其他提高开发人员生产力的功能，包括子类型化，任意精度算术和垃圾回收。

Motoko 并非（也不打算成为）实现容器的唯一语言。 如果它不适合您的需求，我们也正在努力为 SDK 添加 Rust 支持。 我们的目标是使任何语言（使用针对 WebAssembly 的编译器）都能够生成可在 Internet 计算机上运行的容器，并通过与语言无关的 Candid 接口与其他（可能是外国的）容器进行互操作。
其量身定制的设计意味着 Motoko 至少在可预见的将来，应该成为在 Internet 计算机上进行编码的最简单，最安全的语言。
关于
Rust语言
如何使用Rust语言工作的介绍
Rust语言是一种强大，安全可靠的现代变成语言，拥有活跃的开发者社区。由于Rust可以编译为WebAssembly，因此它提供了丰富的开发环境来编写可在互联网计算机上运行的应用程序。为了帮助铺平可以在Internet计算机上部署的用Rust编写应用程序的方式，DFINITY提供了一些工具来简化该过程。
这些工具就是用于支持Rust的DFINITY Canister开发套件（CDK），包括以下主要库：
图片: https://uploader.shimo.im/f/FX9xtDHEueSiKyi8.png


七、Internet Computer 接口规范
简介
欢迎使用互联网计算机！我们称其为“ 互联网计算机”，是因为尽管在幕后仍有大量物理计算机以不平凡的方式协同工作，但我们终于拥有了整体、共享、安全且可在全球范围内访问的计算机。 使用互联网计算机部署应用程序的开发者和他们的用户，也无需再处理高级而复杂的硬件设备问题。

目标受众
本文档描述了互联网计算机的外部视图，即它向应用程序开发人员和用户提供的初级接口，以及当他们使用这些接口时会发生什么。
注意：
虽然本文档描述了互联网计算机的外部接口和行为，但它不是终端用户或终端开发者文档。大多数开发人员仍需通过 SDK,Canister 开发包、Motoko 等其他工具与互联网计算机进行交互。请查看 https://sdk.dfinity.org/ 以找到合适的文档。

本文档的目标读者是
使用这些底层接口的人员（例如：实现代理，canister工具包开发，模拟器，其他工具）。
那些实现这些底层接口的人（例如Internet Computer实现的开发人员）
那些想详细了解Internet Computer行为复杂性的人（例如进行安全分析）

警告：
本文档是严格的技术参考。它不是Internet Computer的简介，因此对于了解高级概念的人员而言非常有用。请首先查看更多高级文档。

如果您将Internet Computer视为提供基于WebAssembly的服务托管服务的分布式执行引擎，则本文档将专门描述其服务托管方面。本文尽可能不讨论区块链，共识协议，节点，子网，正交持久性或治理治理模式。
本文试图与实现无关，它同样适用于（假设的）兼容的Internet Computer的重新实现。这意味着本文档不涵盖面向运行Internet Computer的接口（例如，数据中心运营商，协议开发人员，治理用户），因为诸如节点更新，监视，日志记录之类的内容，固有地与实际实现及其体系结构相关。
互联网计算机概述
如果要使用Internet Computer作为应用程序的开发人员，则首先需要创建一个Canister模块，其中包含应用程序的WebAssembly代码和配置，然后使用HTTP接口进行部署。您更加方便可以使用Motoko语言和SDK创建容器。但是，如果您想使用自己的工具包，那么本文档将描述容器模块看起来是什么样的以及WebAssembly代码如何与系统交互。
一旦您的应用程序在Internet Computer上运行，​​它就是一个容器，用户可以与它进行交互。他们可以根据系统API使用HTTP接口与容器进行交互。
用户还可以使用HTTP接口发出只读查询，该查询速度更快，但无法更改容器的状态。
图片: https://uploader.shimo.im/f/485sfRPORXoN0j4v.png
图1. Internet Computer的典型用法。（这是一个简化的视图；箭头表示多个交互步骤或轮询。）

“ HTTPS接口”和“容器接口（系统API） ”的部分描述了这些接口，并简要说明了它们的作用。之后，您将找到对Internet计算机的更正式的描述，该描述更严格地描述了其抽象行为。

命名规则
为了使本文档具有一定的一致性，我们尝试精确地使用以下术语：

我们避免使用“客户端（client）”一词，因为它可能是Internet Computer的客户端，也可能是组成Internet Computer的分布式网络中的客户端。取而代之的是，我们使用术语“用户（user）”来表示与Internet Computer交互的外部实体，即使在大多数情况下它将会是代表（人类）用户的某些代码（有时称为“代理（agent）”）。

Canisters的公共入口(public entry point)称为方法（method）。可以将方法声明为更新方法( update methods )（保留状态变化）或查询方法（query method）（丢弃状态变化，无法进行进一步的调用）。

方法可以被称为从请求方到被请求方，并最终招致响应 既不是一个 返回(reply) 或 拒绝(reject)。方法可能具有参数，这些参数在方法的调用中提供了具体的参数数据。

内部容器（inter-canister）间调用不能区分更新方法和查询方法。内部容器的调用可以保留状态变化，因此类似于更新方法调用。请注意，canister向自身发出的调用(call)也算作“内部容器”。外部调用可以是可同时调用两种方法的：更新调用 和仅可调用查询方法的查询调用。

在内部，调用或响应作为消息(message)从发送方(sender)发送到接收方(receiver)。消息是没有响应(response)的。

WebAssembly 函数由WebAssembly模块导出或由System API提供。这些函数可以被调用，并且可以捕获或返回（可能带有返回值）。函数也具有并带有参数。

外部用户(user)通过在HTTPS接口上发出请求(request)来与系统交互。请求的响应可以是正常返回(repliy)，也可以是拒绝(reject)。某些请求会创建内部消息。

容器，用户等由标识码(principal)（有时也称为id）标识。

未指定的常数和限制
本规范可能引用某些常量和限制，但未指定其具体值（暂时），即它们是由实现定义的。许多资源限制仅与指定系统的错误处理行为有关（如上所述，在本文​​档中也没有对此进行精确描述）。此列表不完整。

MAX_CYCLES_PER_MESSAGE
尝试执行一条消息之前，canister必须具有的周期数，这将从消息执行之前的canister余额中扣除。请参阅消息执行。
MAX_CANISTER_BALANCE
最大canister周期余额。任何多余的余额都将被抛弃。小于2^64。

标识码
就系统的大多数用途而言，标识码（例如：canister,用户和子网ID）都是二进制blob，长度在0到29个字节之间。但是，它们具有某种结构来编码特定的身份验证和授权行为。
ID的特殊结构
在本节中，H表示SHA-224，·表示blob联系，|p|表示p以字节为单位的长度，编码为单个字节。
id有几种类别：
 不透明ID。
这些总是由系统生成的，并且在系统外部没有任何有意义的结构。
注意：
通常，这些以byte 0x01结尾，但是IC的用户不必关心这一点。
自我认证ID。
格式：H(public_key) · 0x02 （29字节）。
 如果外部用户拥有相应的私钥，则可以将这些ID作为 sender 用作请求的ID 。公钥使用签名中的编码之一。
派生ID
格式：H(|registering_principal| · registering_principal · derivation_nonce) · 0x03（29字节）。

当一个ID需要注册时，将对这些ID进行特殊处理。在这样的请求中，请求ID的人都可以提供derivation_nonce。通过将其与请求方的标识码进行拼凑，每个标识码都有一个ID空间，只有他们才能从中注册ID。 

注意：
派生ID当前未在本文档中明确使用，但可以在内部或将来使用。
匿名ID
格式为0x04，用于匿名调用方。可以在没有签名的情况下用于调用和查询请求。 

当系统创建一个新的 ID时，它永远不会创建一个自我认证ID，匿名ID或着是可能来自容器或用户的ID。

标识码的文字表述
 注意：
该文本表示形式实际上并未显示在界面中（界面中永远为blob），因此它只是建议的约定。
我们指定规范的文本格式，在需要以文本格式打印或阅读主体时（例如在日志消息，事务浏览器，命令行工具，源代码中）建议使用此格式。
blob 的文本表述 b 为 rouped(Base32(CRC32(b) · b))其中
CRC32是一个四字节的校验序列，按照ISO 3309，ITU-T V.42和其他规定定义
Base32是RFC 4648中定义的Base32编码，未添加填充字符。
中间的点表示连接。
Grouped接受一个ASCII字符串，并-每5个字符插入一个分隔符（破折号）。最后一组可能包含少于5个字符。分隔符永远不会出现在开头或结尾。
 
文本表示通常以小写字母打印，但不区分大小写地进行解析。
因为标识码的最大大小为29个字节，所以文字表述将不超过63个字符（10乘以5加3个字符，中间有10个分隔符）。

提示：
canister的ID 0xABCD01 有检查顺序 0x233FF206（在线计算器）；因此，最终ID为em77e-bvlzu-aq。
bash中从十六进制编码到十六进制的示例编码（可以将以下内容粘贴到终端中）：
function textual_encode() {
  ( echo "$1" | xxd -r -p | /usr/bin/crc32 /dev/stdin;     echo -n "$1" ) |
  xxd -r -p | base32 | tr A-Z a-z |
  tr -d = | fold -w5 | paste -sd'-' -
}
function textual_decode() {
  echo -n "$1" | tr -d - | tr a-z A-Z |
  fold -w 8 | xargs -n1 printf '%-8s' | tr ' ' = |
  base32 -d | xxd -p | tr -d '\n' | cut -b9- | tr a-z A-Z
}
签名
数字签名方案用于在IC基础架构的各个部分中对消息进行身份验证。签名是域分隔的，这意味着每条消息都以一个唯一的字节字符串作为前缀，以达到这对于签名的目的。IC支持普通签名以及通过Web身份验证生成的签名。

支持纯签名方案
Ed25519或
使用SHA-256作为哈希函数的曲线P-256 ECDSA（也称为 secp256r1）以及Koblitz曲线上的 secp256k1
通过 对域分隔符和消息的联系进行签名，来计算签名。
公钥必须对签名方案Ed25519或ECDSA有效，并且编码为DER。
有关Ed25519公钥的DER编码，请参阅RFC 8410。
有关ECDSA公钥的DER编码，请参阅RFC 5480；请参阅RFC 5480。DER编码不得指定哈希函数。对于曲线secp256k1，使用OID 1.3.132.0.10。主要是必须指定以未压缩形式（也就是说 0x04随后的高位编址32字节编码x和y）。 
签名被编码为两个值r和s的32字节大字节序编码的连接。
只能通过Web身份验证的的签名方案
使用SHA-256作为哈希函数的曲线P-256 ECDSA（也称为 secp256r1）以及Koblitz曲线上的 secp256k1
通过使用域分隔符和消息的连接作为Web验证断言中的Challenge来计算签名。
通过验证 challenge 字段是否包含域分隔符和消息的连接的base64url编码，并按照WebAuthn w3c建议中的规定进行signature 验证 authenticatorData · SHA-256(utf8(clientDataJSON))，来检查签名。
公用密钥被编码为DER封装的COSE密钥，如下所述。
签名是具有三个必填字段的Map的CBOR编码：
authenticator_data（blob）：WebAuthn身份验证器数据。 
client_data_json（text）：JSON格式的WebAuthn客户端数据。 
signature（blob）：WebAuthn w3c建议中指定的签名，对于ECDSA签名来说这是DER编码。 

DER包裹的COSE格式使用SubjectPublicKeyInfo类型，其他的公共密钥（例如，参见RFC 8410，第4节），以及OID 1.3.6.1.4.1.56387.1.1（iso.org.dod.internet.private）。 enterprise.dfinity.mechanisms.der-wrapped-cose）。该BIT STRING字段subjectPublicKey包含COSE编码。有关COSE编码的详细信息，请参阅WebAuthn w3c建议或RFC 8152。 

提示：
A DER wrapping of a COSE key is shown below. It can be parsed via the command sed "s/#.*//" | xxd -r -p | openssl asn1parse -inform der.
30 5E                                                     # 长度为94字节的序列
  30 0C                                                   # 长度为12个字节的序列
    06 0A 2B 06 01 04 01 83 B8 43 01 01     # OID 1.3.6.1.4.1.56387.1.1
  03 4E 00                                               # 长度为78的BIT STRING编码,
    A501 0203 2620 0121 5820 7FFD 8363 2072   ＃  长度位于字节边界
    FD1B FEAF 3FBA A431 46E0 EF95 C3F5 5E39 #   内容是验证过的COSE密钥
    94A4 1BBF 2B51 74D7 71DA 2258 2032 497E  #   ECDSA在曲线P-256 上
    ED0A 7F6F 0009 2876 5B83 1816 2CFD 80A9
    4E52 5A6A 368C 2363 063D 04E6 ED
您还可以在在线ASN.1 JavaScript解码器中查看包装。
系统状态树
系统状态的一部分是公开的（例如，通过请求：读状态或认证数据）的验证方法（见认证中机械证明）。本节会抽象地描述系统状态的内容。

从概念上讲，系统状态是一棵带有标签子枝的树，叶中有值。等效地，系统状态是从路径（标签序列）到值的映射，其中的域是无前缀的。

标签始终是二进制大对象（但通常具有人类可读的表现形式）。在本文档中，建议使用斜线作为分隔符来编写路径。实际的编码实际上并没有使用斜杠作为分隔符，并且标签可能正常包含了0x2F字节（ASCII /）。值可以是自然数，文本值或二进制大对象。 

本节指定了树中与公共相关的路径。

认证时间
/time （自然）：
所有证书树都包含一个时间戳，指示状态树当前的时间。

子网信息
状态树包含有关Internet Computer拓扑的信息。
  /subnet/<subnet_id>/public_key （blob）
子网的公共密钥（DER编码的BLS密钥，请参阅认证）
 
 


 
